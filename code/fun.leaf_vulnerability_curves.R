
######################################################
# This is Valentine Herrmann's script  - HerrmannV@si.edu
# https://github.com/EcoClimLab/HydraulicTraits/blob/master/scripts/Closure_Script_functions.R
# HydraulicTraits/scripts/Closure_Script_functions.R
# R version 3.5.1 (2018-07-02)
# Modified by: Rutuja Chitra-Tarak
# Date: Aug 15, 2020
######################################################
if (!require("pacman")) install.packages("pacman"); library(pacman)
pacman::p_load(likelihood)

#Define functions and parameter values

# The high values for all of these functions are sort of arbitrary.
# I set the original limits thinking that fitted gmax wouldn't be too
# much higher than measured gmax, and that P50 should be between 0 and -5 MPa,
# and then just ran the script a few times with different values to see if I could
# improve the number of curves it successfully fit. Using different par values for each model type
# helped a lot.
## In the exponential function, the effect of changing Xo (the intercept) on kl
# is usually very small compared to that of any of the other parameters, so it is hard to fit
# with any kind of precision. This makes it hard to estimate error terms for Xo, and increases
# the error in the other parameters, since the model can't tell whether a given improvement in
# fit came from changing Xo or another parameter. I had very little success fitting Xo without
# NAs in the error terms, but the model fit really well when I removed Xo from the equation.
# I was concerned we wouldn't capture the tail of the function when kl is close to 0,
# but the graphs of the exponential fits look fine. I think this is a reasonable simplification
# and improves model fit, but if you think Xo is important, then you might have to fit it one
# curve at a time.
Exponential <- function (A, B, psi) {
  A * exp(-B * psi)
}
Exponential2 <- function (A, B, C, psi) {
  C + A * exp(-B * psi)
}
Logistic <- function (A, B, Xo, psi) {
  A / (1 + ((psi / Xo) ^ B))
}
Sigmoidal <- function (A, B, Xo, psi) {
  A / (1 + exp(-((psi - Xo) / B)))
}

# define parameters

define_parameters <- function(input_df) {
  return(list(
    Exponential = list(
      pars = list(A = max(input_df$kl), B = 1, sd = 2),
      par_low = list(A = 0, B = 0.1, sd = 0.0005),
      par_high = list(A = max(input_df$kl) * 2, B = 10, sd = 50),
      color = "blue",
      Kmax_formula = "A",
      psi_kl_formula = "log( (Kmax * probs) / A) / (-B)"
    ),
    Exponential2 = list(
      pars = list(A = max(input_df$kl), B = 1, C = .1, sd = 2),
      par_low = list(A = 0, B = 0.1, C = .001, sd = 0.0005),
      par_high = list(A = max(input_df$kl) * 2, B = 20, C = 20, sd = 50),
      color = "cornflowerblue",
      Kmax_formula = "C + A",
      psi_kl_formula = "log(((Kmax * probs) - C)/A) / (-B)"
    ),
    Logistic = list(
      pars =  list(A = max(input_df$kl), B = 5, Xo = 2, sd = 2),
      par_low = list(A = 0, B = 0.1, Xo = -5, sd = 0.0005),
      par_high = list(A = max(input_df$kl) * 2, B = 25, Xo = 5, sd = 50),
      color = "coral2",
      Kmax_formula = "A",
      psi_kl_formula = "Xo * (A / (Kmax * probs) -1) ^ (1/B)"
    ),
    Sigmoidal = list(
      pars = list(A = max(input_df$kl), B = -0.5, Xo = 2, sd = 2),
      par_low =  list(A = 0, B = -1.25, Xo = -5, sd = 0.0005),
      par_high = list(A = max(input_df$kl) * 1.5, B = 0, Xo = 6, sd = 50),
      color = "darkolivegreen4",
      Kmax_formula = "A / (1 + exp(Xo / B))",
      psi_kl_formula = "log(A / (Kmax * probs) -1) * (-B) + Xo"
    ))
  )
}


do_the_thing <-
  function(input_df,
           model_types, model_parameters, TLP_mean = NULL, TLP_sd = NULL) {


    var <- list(
      psi = "psi",
      x = "kl",
      mean = "predicted",
      log = TRUE
    ) #It looks weird that kl is the x variable here, but anneal calculates the slope and R2 of the fit using the predicted kl values as the y and the observed kl values as the x


    #Plot the raw data
    plot(
      input_df$psi,
      input_df$kl,
      xlab = "Leaf Water Potential (-MPa)",
      ylab = "",
      col = "gray",
      pch = 19,
      cex = 1.3,
      xlim = c(0, 3.5),
      ylim = c(0, max(input_df$kl)),
      las = 1
    )

    mtext(text = expression("Leaf Hydraulic Conductance (mmol "~m^-2*s^-1*MPa^-1*")"), side = 2, line = 2)
    title(paste(input_df[1, 1], input_df[1, 2]))

    all_models <- c(Exponential, Exponential2, Logistic, Sigmoidal)
    all_models_names <- c("Exponential", "Exponential2", "Logistic", "Sigmoidal")
    model_names_in_this_case = all_models_names[ match(model_types, all_models)]

    parvecLog_all <- NULL

    for( model_type in model_types) {

      idx_model <- sapply(all_models, function(x) identical(x, model_type))
      print(paste("fiting",  all_models_names[idx_model], "curve"))

      pars = model_parameters[idx_model][[1]]$pars
      par_lo = model_parameters[idx_model][[1]]$par_low
      par_hi = model_parameters[idx_model][[1]]$par_high
      color = model_parameters[idx_model][[1]]$color

      res <-
        anneal(
          model = model_type,
          par = pars,
          source_data = input_df,
          var = var,
          par_lo = par_lo,
          par_hi = par_hi,
          dep_var = "kl",
          pdf = dnorm,
          max_iter = 50000,
          show_display = F,
          temp_red = 0.05
        )


      #Setting the parameters to change slowly in the fitting procedure (the temp_red variable)
      # helped a lot. You can watch the fitting proceed with show_display, but I've never found it
      # very informative

      #AIC formula: -2LL + 2*parameters (incl nuisance, i.e.,sd)

      AIC <- res$aic

      #AICcorr formula: -2LL + (2*n*parameters (incl nuisance, i.e.,sd)/(n-parameters-1))

      AICcorr <- res$aic_corr

      slope <- sum(res$source_data$predicted * res$source_data$kl) / sum(res$source_data$predicted ^2)

      rsq <- res$R2

      sterror <- res$std_errs

      N <- length(res$source_data$kl)


      parvecLog <-
        data.frame(
          model_type = all_models_names[idx_model],
          Species = paste(input_df[1, 1]),
          data.type = paste(input_df[1, 2]),
          A = res$best_pars[[1]],
          B = res$best_pars[[2]],
          C = ifelse("C" %in% names(res$best_pars), res$best_pars$C, NA),
          Xo = ifelse("Xo" %in% names(res$best_pars), res$best_pars$Xo, NA),
          sd = res$best_pars$sd,
          loglikeli = res$max_likeli,
          rsq = rsq,
          slope = slope,
          AIC = AIC,
          AICcorr = AICcorr,
          sterror.A = sterror[[1]],
          sterror.B = sterror[[2]],
          sterror.C.or.Xo = ifelse(length(sterror) >3 , sterror[[3]], NA),
          sterror.sd = sterror$sd,
          N = N
        )

      parvecLog$Kmax <- with(parvecLog,  eval(parse(text = model_parameters[idx_model][[1]]$Kmax_formula)))
      parvecLog$psi_kl20 <- with(parvecLog,  eval(parse(text = gsub("probs", "0.8", model_parameters[idx_model][[1]]$psi_kl_formula))))
      parvecLog$psi_kl50 <- with(parvecLog,  eval(parse(text = gsub("probs", "0.5", model_parameters[idx_model][[1]]$psi_kl_formula))))
      parvecLog$psi_kl80 <- with(parvecLog,  eval(parse(text = gsub("probs", "0.2", model_parameters[idx_model][[1]]$psi_kl_formula))))
      parvecLog$psi_kl88 <- with(parvecLog,  eval(parse(text = gsub("probs", "0.12", model_parameters[idx_model][[1]]$psi_kl_formula))))
      parvecLog$psi_kl95 <- with(parvecLog,  eval(parse(text = gsub("probs", "0.05", model_parameters[idx_model][[1]]$psi_kl_formula))))


      parvecLog$Kmax_0.5 <- mean(res$source_data$predicted[res$source_data$psi <= 0.5])
      parvecLog$psi_Kmax_0.5 <- mean(res$source_data$psi[res$source_data$psi <= 0.5])
      parvecLog$psi_0.5_kl50 <- with(parvecLog,  eval(parse(text = gsub("Kmax", "Kmax_0.5", gsub("probs", "0.5", model_parameters[idx_model][[1]]$psi_kl_formula)))))
      parvecLog$psi_0.5_kl80 <- with(parvecLog,  eval(parse(text = gsub("Kmax", "Kmax_0.5", gsub("probs", "0.2", model_parameters[idx_model][[1]]$psi_kl_formula)))))
      parvecLog$psi_0.5_kl88 <- with(parvecLog,  eval(parse(text = gsub("Kmax", "Kmax_0.5", gsub("probs", "0.12", model_parameters[idx_model][[1]]$psi_kl_formula)))))

      function_to_apply <- as.character(body(model_type))[2]
      parvecLog$Kmax_at_0.1 <- with(data.frame(parvecLog, psi = .1), eval(parse( text = function_to_apply)))
      parvecLog$psi_at_0.1_kl50 <- with(parvecLog,  eval(parse(text = gsub("Kmax", "Kmax_at_0.1", gsub("probs", "0.5", model_parameters[idx_model][[1]]$psi_kl_formula)))))
      parvecLog$psi_at_0.1_kl80 <- with(parvecLog,  eval(parse(text = gsub("Kmax", "Kmax_at_0.1", gsub("probs", "0.2", model_parameters[idx_model][[1]]$psi_kl_formula)))))
      parvecLog$psi_at_0.1_kl88 <- with(parvecLog,  eval(parse(text = gsub("Kmax", "Kmax_at_0.1", gsub("probs", "0.12", model_parameters[idx_model][[1]]$psi_kl_formula)))))


      # plot the fit

      for_plotting <- cbind(res$source_data$psi, res$source_data$predicted)
      for_plotting <- for_plotting[order(for_plotting[, 1]), ]

      lines(for_plotting[, 1], for_plotting[, 2], col = color)

      # abline(v = c(parvecLog$psi_kl50, parvecLog$psi_kl80), lty = c(1,2), col = color)
      abline(v = c(parvecLog$psi_kl80, parvecLog$psi_0.5_kl80, parvecLog$psi_at_0.1_kl80), lty = c(1,2, 3), col = color)

      parvecLog_all <- rbind(parvecLog_all, parvecLog)

    } # for (model_type in model_types)

    best_model_order <- order(parvecLog_all$AICcorr)


    # if(!is.null(TLP_mean)) {
    #   function_to_apply <- as.character(body(model_types[[best_model_order[1]]]))[2]
    #   y <- with(data.frame(parvecLog_all[best_model_order[1], ], psi = -(TLP_mean)), eval(parse( text = function_to_apply)))
    #   points(x = -(TLP_mean), y = y, pch = 16)
    #   arrows(x0 = -(TLP_mean) - TLP_sd, x1 = -(TLP_mean) + TLP_sd, y0 = y, y1 = y, pch = 16, angle = 90, code = 3, length= 0.02)
    # }

    # legend("topright",
    #        lty = c(rep(1, 5), 2),
    #        col = c(sapply(model_parameters, "[[", "color")[best_model_order], "grey", "grey"),
    #        legend = c(paste(all_models_names, " - AICc", round(parvecLog_all$AICcorr, 2))[best_model_order], "P50", "P80"),
    #        bty = "n")

    legend("topright",
           lty = c(rep(1, (length(model_types) +1)), 2, 3, 1), pch = c(rep(NA, (length(model_types) +3)), 16),
           col = c(sapply(model_parameters, "[[", "color")[best_model_order], "grey", "grey", "grey", "black"),
           legend = c(paste(model_names_in_this_case, " - AICc", round(parvecLog_all$AICcorr, 2))[best_model_order], "P80 - Kmax extrapolated", "P80 - Kmax average <0.5", "P80 - Kmax at 0.1", "TLP +/- 1SD"),
           bty = "n")

    return(parvecLog_all)

  }
